import { TypeId } from "./type";
export class Schema {
    constructor(name, fields, details, meta) {
        this.name = name;
        this.fields = fields;
        this.flags = details.flags;
        this.size = details.size;
        this.optionalFields = details.optionalFields;
        this.booleanFields = details.booleanFields;
        this.bitSet = details.bitSet;
        this.meta = meta;
    }
    hasBitSet() {
        return (this.flags & 1 /* BitSet */) !== 0;
    }
    optionalBitSetIndex(field) {
        return bitSetIndex(this.optionalFields, field);
    }
    booleanBitSetIndex(field) {
        return bitSetIndex(this.booleanFields, field, this.optionalFields.length);
    }
    hasDynamicSize() {
        return (this.flags & 2 /* DynamicSize */) !== 0;
    }
    hasOptionalFields() {
        return (this.flags & 4 /* OptionalFields */) !== 0;
    }
    hasBooleanFields() {
        return (this.flags & 8 /* BooleanFields */) !== 0;
    }
    hasRegularFields() {
        return (this.flags & 16 /* RegularFields */) !== 0;
    }
    bitSetSize() {
        return Math.ceil(this.bitSet.length / 8);
    }
}
export function schema(name, fields, ...meta) {
    const normalizedFields = normalizeFields(fields);
    const m = new Map();
    for (const kv of meta) {
        m.set(kv.key, kv.value);
    }
    return new Schema(name, normalizedFields, analyzeFields(normalizedFields), m);
}
function _normalizeFields(result, fields) {
    for (const f of fields) {
        if (f !== null) {
            if (Array.isArray(f)) {
                _normalizeFields(result, f);
            }
            else {
                result.push(f);
            }
        }
    }
}
function normalizeFields(fields) {
    const result = [];
    _normalizeFields(result, fields);
    return result;
}
function analyzeFields(fields) {
    const optionalFields = [];
    const booleanFields = [];
    const bitSet = [];
    let flags = 0;
    let size = 0;
    for (const field of fields) {
        if ((field.type.flags & 1 /* DynamicSize */) !== 0) {
            flags |= 2 /* DynamicSize */;
        }
        else {
            size += field.type.size;
        }
        if ((field.flags & 1 /* Optional */) !== 0) {
            flags |= 4 /* OptionalFields */;
            optionalFields.push(field);
        }
        if (field.type.id === TypeId.Bool) {
            flags |= 8 /* BooleanFields */;
            booleanFields.push(field);
        }
        else {
            flags |= 16 /* RegularFields */;
        }
    }
    if (optionalFields.length > 0) {
        for (const field of optionalFields) {
            bitSet.push({ type: 1 /* Optional */, field });
        }
    }
    if (booleanFields.length > 0) {
        for (const field of booleanFields) {
            bitSet.push({ type: 2 /* Boolean */, field });
        }
    }
    if (bitSet.length > 0) {
        flags |= 1 /* BitSet */;
        size += Math.ceil(bitSet.length / 8);
    }
    return { flags, size, optionalFields, booleanFields, bitSet };
}
function bitSetIndex(fields, field, offset = 0) {
    let position = offset + fields.indexOf(field);
    let index = 0;
    while (position > 0) {
        if (position > 32) {
            position -= 32;
        }
        else if (position > 16) {
            position -= 16;
        }
        else if (position > 8) {
            position -= 8;
        }
        else {
            break;
        }
        index++;
    }
    return { index, position };
}
//# sourceMappingURL=schema.js.map