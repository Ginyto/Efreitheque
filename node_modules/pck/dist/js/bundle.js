export class Bundle {
    constructor(schemas, types, fixedSizeSchemas, oneOfSchemas) {
        this.schemas = schemas;
        this.types = types;
        this.fixedSizeSchemas = fixedSizeSchemas;
        this.oneOfSchemas = oneOfSchemas;
        this.index = new Map();
        for (const schema of schemas) {
            if (this.index.has(schema.name)) {
                throw new Error(`Failed to bundle, found two schemas with the name ${schema.name}`);
            }
            this.index.set(schema.name, schema);
        }
    }
    findSchemaByName(name) {
        return this.index.get(name);
    }
    isOneOfSchema(schema) {
        return this.oneOfSchemas.get(schema);
    }
}
export function bundle(schemas) {
    const analyzeResult = analyzeSchemas(schemas);
    return new Bundle(schemas, analyzeResult.types, analyzeResult.fixedSizeSchemas, analyzeResult.oneOfSchemas);
}
function analyzeSchemas(schemas) {
    const types = new Set();
    const fixedSizeSchemas = new Set();
    const oneOfSchemas = new Map();
    let oneOfIndex = 0;
    for (const schema of schemas) {
        if (!schema.hasDynamicSize()) {
            fixedSizeSchemas.add(schema);
        }
        for (const field of schema.fields) {
            types.add(field.type);
            if (field.type.isOneOf()) {
                for (const oneOfType of field.type.props) {
                    if (oneOfType.isRef()) {
                        oneOfSchemas.set(oneOfType.props, oneOfIndex++);
                    }
                }
            }
        }
    }
    return {
        types,
        fixedSizeSchemas,
        oneOfSchemas,
    };
}
//# sourceMappingURL=bundle.js.map